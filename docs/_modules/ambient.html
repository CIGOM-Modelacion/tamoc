<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ambient &mdash; Texas A&amp;M Oilspill Calculator v1.1 Manual</title>
    
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Texas A&amp;M Oilspill Calculator v1.1 Manual" href="../contents.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
<li><a href="../index.html">Texas A&M Oilspill Calculator v1.1 Manual</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ambient</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Ambient Module</span>
<span class="sd">==============</span>

<span class="sd">Define functions, classes, and methods to handle ambient sewater data</span>

<span class="sd">This module defines functions to read in arbitrary format ambient data files</span>
<span class="sd">(e.g., CTD profiles), manipulate the data to extract profiles with monotonic</span>
<span class="sd">depth coordinate values, and adjust parameter units to standard units. It also</span>
<span class="sd">defines functions and classes to store the measured CTD data in</span>
<span class="sd">netCDF4-classic format following NODC guidelines and to manipulate the data</span>
<span class="sd">for use by simulation models in ``TAMOC``. These manipulations include</span>
<span class="sd">interpolation methods, the ability to add or remove data from the database,</span>
<span class="sd">including the addition of synthetic data when needed, and to extend a profile</span>
<span class="sd">to deeper depths using a rational means of maintaining the stratification</span>
<span class="sd">structure.</span>

<span class="sd">These methods are particularly useful to rapidly create ambient profile </span>
<span class="sd">databases for use by ``TAMOC`` and for archiving data obtained from arbitrary </span>
<span class="sd">formats in standard format netCDF4-classic files.  These methods also allow</span>
<span class="sd">seemless coupling of ``TAMOC`` simulation modules with general ocean </span>
<span class="sd">circulation models or Lagrangian particle tracking models that store their </span>
<span class="sd">seawater properties data in netCDF format.</span>

<span class="sd">See Also</span>
<span class="sd">--------</span>
<span class="sd">`netCDF4` : </span>
<span class="sd">    Package for creating and manipulating netCDF datasets</span>

<span class="sd">`datetime` : </span>
<span class="sd">    Package to create and manipute dates</span>

<span class="sd">`numpy.fromfile` :</span>
<span class="sd">    Read data from a simple text file in single table format. Similar to the</span>
<span class="sd">    Matlab `load` function. Does not support comments or skipped lines. Works</span>
<span class="sd">    for text or binary files.</span>

<span class="sd">`numpy.loadtxt` : </span>
<span class="sd">    A more sophisticated method to read data from a text file. This method can</span>
<span class="sd">    handle multiple data types (e.g., strings, floats, and integers together),</span>
<span class="sd">    can perform transformation on the data (e.g., date format to a date</span>
<span class="sd">    object), and can unpack to a tuple of variables. One limitation is that</span>
<span class="sd">    all rows must have the same number of columns and there is no method to</span>
<span class="sd">    handle missing data.</span>

<span class="sd">`numpy.genfromtxt` : </span>
<span class="sd">    The most advanced numpy method to read data from a file. Includes the</span>
<span class="sd">    capabilities in `numpy.loadtxt`, but also allows for missing data, data</span>
<span class="sd">    flags, and multiple methods to replace missing data or flags.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># S. Socolofsky, July 2013, Texas A&amp;M University &lt;socolofs@tamu.edu&gt;.</span>

<span class="kn">from</span> <span class="nn">tamoc</span> <span class="kn">import</span> <span class="n">seawater</span>

<span class="kn">from</span> <span class="nn">netCDF4</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">netCDF4</span> <span class="kn">import</span> <span class="n">num2date</span><span class="p">,</span> <span class="n">date2num</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">ctime</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">capwords</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

<div class="viewcode-block" id="Profile"><a class="viewcode-back" href="../modules/ambient.html#ambient.Profile">[docs]</a><span class="k">class</span> <span class="nc">Profile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class object for ambient seawater profiles</span>
<span class="sd">    </span>
<span class="sd">    This object collects the data describing the ambient seawater (e.g., </span>
<span class="sd">    CTD data, currents, etc.) and provides efficient access to interpolated</span>
<span class="sd">    results at arbitrary depths.  All of the raw data are stored in a </span>
<span class="sd">    netCDF4-classic format dataset, which resides on the hard-drive.  Profile</span>
<span class="sd">    objects can be initiated either from an open netCDF dataset object or </span>
<span class="sd">    from a file path to the desired object.  The netCDF dataset is expected</span>
<span class="sd">    to have variables for &#39;z&#39;, &#39;temperature&#39;, &#39;salinity&#39;, and &#39;pressure&#39; and </span>
<span class="sd">    any other variables requested at instantiation through the chem_names</span>
<span class="sd">    variable.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nc : netCDF dataset object, path, or str</span>
<span class="sd">        Provides the information necessary to access the netCDF dataset.  If</span>
<span class="sd">        a file path or string is provided, then the netCDF file is opened</span>
<span class="sd">        and the resulting dataset object is stored in self.nc.</span>
<span class="sd">    ztsp : str list</span>
<span class="sd">        String list containing the variables names for depth, temperature, </span>
<span class="sd">        salinity, and pressure that are used in the netCDF dataset.</span>
<span class="sd">    chem_names : str list, optional</span>
<span class="sd">        Names of the chemicals (e.g., those constituents in addition to z, T, </span>
<span class="sd">        S, P) in the netCDF dataset that should be accessible through the </span>
<span class="sd">        `self.get_values` interpolation method or the `self.get_units` </span>
<span class="sd">        interrogator.  If `chem_names` = &#39;all&#39;, then all variables in the </span>
<span class="sd">        netCDF file except for &#39;time&#39;, &#39;lat&#39;, &#39;lon&#39;, and the strings in </span>
<span class="sd">        `ztsp` will be loaded as ambient chemical data.</span>
<span class="sd">    err : float</span>
<span class="sd">        The interpolation dataset is a subset of the complete raw dataset </span>
<span class="sd">        stored in the netCDF file.  err sets the acceptable level of </span>
<span class="sd">        relative error using linear interpolation expected of the </span>
<span class="sd">        `self.get_values` method.  This value is passed to the `coarsen` </span>
<span class="sd">        function to provide an optimal interpolation dataset.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nc_open : bool</span>
<span class="sd">        Flag stating whether or not the netCDF dataset is open or closed</span>
<span class="sd">    nchems : int </span>
<span class="sd">        Number of chemicals in `chem_names`</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Array containing the complete raw dataset of depths</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        Array containing the complete raw dataset for T, S, P, and chemicals </span>
<span class="sd">        in `chem_names`. </span>
<span class="sd">    f_names : str list</span>
<span class="sd">        concatenated string list containing `ztsp` and `chem_names`</span>
<span class="sd">    f_units : str list</span>
<span class="sd">        List of units associated with the variables stored in `f_names`.</span>
<span class="sd">    f : object</span>
<span class="sd">        `scipy.interpolate.interp1d` object containing `z` and `y`.</span>
<span class="sd">    </span>
<span class="sd">    See Also </span>
<span class="sd">    --------</span>
<span class="sd">    netCDF4, create_nc_db, fill_nc_db, coarsen, chemical_properties</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; bm54 = Profile(&#39;./test/output/test_BM54.nc&#39;, chem_names=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print bm54.nc.variables.keys()</span>
<span class="sd">    [&#39;time&#39;, &#39;lat&#39;, &#39;lon&#39;, &#39;z&#39;, &#39;temperature&#39;, &#39;salinity&#39;, &#39;pressure&#39;, </span>
<span class="sd">    &#39;T&#39;, &#39;wetlab_fluorescence&#39;, &#39;S&#39;, &#39;density&#39;, &#39;oxygen&#39;]</span>
<span class="sd">    &gt;&gt;&gt; bm54.get_values(1000.0, [&#39;temperature&#39;, &#39;salinity&#39;, &#39;pressure&#39;])</span>
<span class="sd">    array([  2.78274540e+02,   3.49278396e+01,   1.01933088e+07])</span>
<span class="sd">    &gt;&gt;&gt; bm54.get_units(&#39;oxygen&#39;)</span>
<span class="sd">    [&#39;kg/m^3&#39;]</span>
<span class="sd">    &gt;&gt;&gt; bm54.buoyancy_frequency(1500.)</span>
<span class="sd">    0.00081815</span>
<span class="sd">    &gt;&gt;&gt; bm54.nc_close()</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ztsp</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="s">&#39;temperature&#39;</span><span class="p">,</span> <span class="s">&#39;salinity&#39;</span><span class="p">,</span> 
                 <span class="s">&#39;pressure&#39;</span><span class="p">],</span> <span class="n">chem_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Profile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        
        <span class="c"># Get the appropriate netCDF dataset object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
        
        <span class="c"># Mark the netCDF file as open</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc_open</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c"># Check chem_names</span>
        <span class="k">if</span> <span class="n">chem_names</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">non_chems</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="s">&#39;lat&#39;</span><span class="p">,</span> <span class="s">&#39;lon&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ztsp</span>
            <span class="n">chem_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">non_chems</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chem_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">chem_names</span> <span class="o">==</span> <span class="p">[</span><span class="n">chem_names</span><span class="p">]</span>
        
        <span class="c"># Store the input variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="n">nc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span> <span class="o">=</span> <span class="n">ztsp</span>
        <span class="k">if</span> <span class="n">chem_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chem_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nchems</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chem_names</span> <span class="o">=</span> <span class="n">chem_names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nchems</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chem_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="n">err</span>
        
        <span class="c"># Build an interpolation function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_interpolator</span><span class="p">()</span>
    
<div class="viewcode-block" id="Profile.build_interpolator"><a class="viewcode-back" href="../ambient/ambient.Profile.build_interpolator.html#ambient.Profile.build_interpolator">[docs]</a>    <span class="k">def</span> <span class="nf">build_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the interpolator function from the netCDF dataset</span>
<span class="sd">        </span>
<span class="sd">        Extract the raw data from the netCDF dataset using the required</span>
<span class="sd">        variables T, S, and P plus any variables requested by the user through</span>
<span class="sd">        `self.chem_names` and store the resulting data in z and y.  Coarsen</span>
<span class="sd">        the raw dataset to the level specified by `self.err` using the </span>
<span class="sd">        `coursen` function and put the resulting reduced dataset into the </span>
<span class="sd">        interpolation function `f`.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is responsible for creating the object attributes `z`, </span>
<span class="sd">        `y`, `f_names`, `f_units`, and `f`.</span>
<span class="sd">        </span>
<span class="sd">        This method is called by the object initializer and by the object </span>
<span class="sd">        append method.  *It should not be called directly by the user*.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_open</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Extract the depths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]][:]</span>
            
            <span class="c"># List the ambient profile components</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem_names</span>
            
            <span class="c"># Extract the ambient profile data and units</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f_units</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="p">[</span><span class="n">i</span><span class="p">]][:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
            
            <span class="c"># Create the interpolation function </span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">coarsen</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="p">)</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">stabilize</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">db</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">db</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            
            <span class="c"># Set the valid range of the interpolator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The netCDF dataset is already closed so &#39;</span> <span class="o">+</span> 
                             <span class="s">&#39;the interpolator cannot be updated.&#39;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Profile.append"><a class="viewcode-back" href="../ambient/ambient.Profile.append.html#ambient.Profile.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">var_symbols</span><span class="p">,</span> <span class="n">var_units</span><span class="p">,</span> <span class="n">comments</span><span class="p">,</span> <span class="n">z_col</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add data to the netCDF dataset and update the object attributes</span>
<span class="sd">        </span>
<span class="sd">        This method provides an interface to the `fill_nc_db` function</span>
<span class="sd">        and performs the necessary updates to all affected object attributes.</span>
<span class="sd">        This is the only way that data should be added to a netCDF file </span>
<span class="sd">        contained in a Profile class object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ndarray</span>
<span class="sd">            Table of data to add to the netCDF database.  If it contains more</span>
<span class="sd">            than one variable, the data are assumed to be arranged in columns.</span>
<span class="sd">        var_symbols : string list</span>
<span class="sd">            List of string symbol names (e.g., T, S, P, etc.) in the same </span>
<span class="sd">            order as the columns in the data array.  For chemical properties,</span>
<span class="sd">            use the key names in the chemical_properties.py database.</span>
<span class="sd">        var_units : string list</span>
<span class="sd">            List of units associated with each variable in the `var_symbols` </span>
<span class="sd">            list.</span>
<span class="sd">        comments : string list</span>
<span class="sd">            List of comments associated with each variable in the </span>
<span class="sd">            `var_symbols` list.  As a minimum, this list should include the </span>
<span class="sd">            indications &#39;measured&#39; or &#39;derived&#39; or some similar indication of </span>
<span class="sd">            source of the data.</span>
<span class="sd">        z_col : integer, default is 0</span>
<span class="sd">            Column number of the column containing the depth data.  The first </span>
<span class="sd">            column is numbered zero.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Once a Profile object is created, data should only be added to the </span>
<span class="sd">        object&#39;s netCDF dataset through this append method.  While direct </span>
<span class="sd">        calls to `ambient.fill_nc_db` will not create errors, the resulting</span>
<span class="sd">        netCDF dataset will no longer be compatible with the Profile object</span>
<span class="sd">        attributes.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_open</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Make sure the constituent names are in a list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_symbols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">var_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_symbols</span><span class="p">]</span>
            
            <span class="c"># Add the data to the netCDF dataset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="n">fill_nc_db</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">var_symbols</span><span class="p">,</span> <span class="n">var_units</span><span class="p">,</span> 
                                 <span class="n">comments</span><span class="p">,</span> <span class="n">z_col</span><span class="p">)</span>
            
            <span class="c"># Add the new chemicals to the chem variables</span>
            <span class="k">for</span> <span class="n">constituent</span> <span class="ow">in</span> <span class="n">var_symbols</span><span class="p">:</span>
                <span class="c"># Make sure the dependent variable is never listed as a </span>
                <span class="c"># chemical</span>
                <span class="k">if</span> <span class="n">constituent</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">chem_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constituent</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nchems</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c"># Rebuild the interpolator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_interpolator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The netCDF dataset is already closed so &#39;</span> <span class="o">+</span> 
                             <span class="s">&#39;data cannot be added to it.&#39;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Profile.get_values"><a class="viewcode-back" href="../ambient/ambient.Profile.get_values.html#ambient.Profile.get_values">[docs]</a>    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return values for the variables listed in `names` interpolated to the</span>
<span class="sd">        depth given by `z`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z : float or ndarray</span>
<span class="sd">            Depth(s) at which data are desired.  If the value of `z` lies </span>
<span class="sd">            outside the `valid_min` or `valid_max` values of `z` in the </span>
<span class="sd">            netCDF dataset, the values at the nearest boundary are returned.</span>
<span class="sd">        names : string list</span>
<span class="sd">            List of variable names (e.g., temperature, oxygen, etc.) for </span>
<span class="sd">            which the interpolated data are desired.  If the parameter name</span>
<span class="sd">            is not present in the database, a value of zero is returned.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yp : ndarray</span>
<span class="sd">            An array of values sorted in the same order as `names` and </span>
<span class="sd">            interpolated at the depth(s) given by `z`.  If `z` is a row </span>
<span class="sd">            vector, `yp` contains `z` in the first column and the other </span>
<span class="sd">            variables in the adjacent columns.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Make sure names is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        
        <span class="c"># Make sure z is an array</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        
        <span class="c"># Catch the out of range error.  This should only occur when an ODE</span>
        <span class="c"># solver gets close to the boundary; thus, it is acceptable to revert</span>
        <span class="c"># to the solution at the boundary</span>
        <span class="n">z</span><span class="p">[</span><span class="n">z</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span>
        <span class="n">z</span><span class="p">[</span><span class="n">z</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span>
        
        <span class="c"># Get the columns in the output where the interpolated data will go</span>
        <span class="n">ans_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> 
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">ans_cols</span><span class="p">:</span>
            <span class="c"># Get the names of these interpolated data</span>
            <span class="n">i_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ans_cols</span><span class="p">]</span>

            <span class="c"># Get the columns in the interpolation dataset where these names </span>
            <span class="c"># are located</span>
            <span class="n">i_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">i_names</span><span class="p">]</span>
            
            <span class="c"># Interpolate the data and insert into the output array</span>
            <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># f(z) will be a row vector</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
                <span class="n">interp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="n">i_cols</span><span class="p">]</span>
                <span class="n">ans</span><span class="p">[</span><span class="n">ans_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># f(z) will be a 2d matrix</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)))</span>
                <span class="n">interp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[:,</span><span class="n">i_cols</span><span class="p">]</span>
                <span class="n">ans</span><span class="p">[:,</span><span class="n">ans_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Return the appropriately shaped zeros matrix</span>
            <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)))</span>
        
        <span class="c"># Always return a ndarray         </span>
        <span class="k">return</span> <span class="n">ans</span>
    </div>
<div class="viewcode-block" id="Profile.get_units"><a class="viewcode-back" href="../ambient/ambient.Profile.get_units.html#ambient.Profile.get_units">[docs]</a>    <span class="k">def</span> <span class="nf">get_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of units for the variables in `names`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">       names : string list</span>
<span class="sd">            List of variable names (T, S, P or entries in `chem_names`) for </span>
<span class="sd">            which the units are desired.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        units : string list</span>
<span class="sd">            A list of strings specifying the units of each variables in the </span>
<span class="sd">            same order as they are listed in `names`</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The names of the units are extracted from the netCDF dataset.  </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Make sure names is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        
        <span class="c"># Return the list of units</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_units</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)])</span>
        
        <span class="k">return</span> <span class="n">ans</span>
    </div>
<div class="viewcode-block" id="Profile.buoyancy_frequency"><a class="viewcode-back" href="../ambient/ambient.Profile.buoyancy_frequency.html#ambient.Profile.buoyancy_frequency">[docs]</a>    <span class="k">def</span> <span class="nf">buoyancy_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the local buoyancy frequency</span>
<span class="sd">        </span>
<span class="sd">        Calculate the buoyancy frequency at the depth `z`, optionally using </span>
<span class="sd">        the length-scale `h` to obtain smooth results.  This calculation uses</span>
<span class="sd">        the in-situ pressure at the depth z as a constant so that the effect</span>
<span class="sd">        of compressibility is removed.  </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z : float or ndarray</span>
<span class="sd">            Depth(s) (m) at which data are desired.  The value of `z` must lie </span>
<span class="sd">            between the `valid_min` and `valid_max` values of `z` in the </span>
<span class="sd">            netCDF dataset.</span>
<span class="sd">        h : float, default value is 0.01</span>
<span class="sd">            Fraction of the water depth (--) to use as the length-scale in a </span>
<span class="sd">            finite-difference approximation to the density gradient.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        N : float</span>
<span class="sd">            The buoyancy frequency (1/s).</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : </span>
<span class="sd">            The input value of `z` must be between the `valid_min` and </span>
<span class="sd">            `valid_max` values of the depth variable of the netCDF dataset.  </span>
<span class="sd">            If it is outside this range, a `ValueError` is raised.</span>
<span class="sd">        ValueError : </span>
<span class="sd">            The parameter `h` must be between zero and one; otherwise, the </span>
<span class="sd">            length-scale of the finite difference approximation will be </span>
<span class="sd">            greater than the water depth.  If `h` is outside this range, a </span>
<span class="sd">            `ValueError` is raised.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses the interpolation function to extract data from the profile; </span>
<span class="sd">        therefore, it may already be smoothed by `coarsen` through the </span>
<span class="sd">        `self.err` value, and the computed values are generally not taken </span>
<span class="sd">        directly from measured data, but rather at interpolation points.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check validity of the input z values</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Selected depths outside range of &#39;</span> <span class="o">+</span> \
                             <span class="s">&#39;CTD data:  </span><span class="si">%g</span><span class="s"> to </span><span class="si">%g</span><span class="s"> m&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Input parameter h must be between 0.0 &#39;</span> <span class="o">+</span> \
                             <span class="s">&#39;and 1.0.&#39;</span><span class="p">)</span>
        
        <span class="c"># Prepare space to store the solution</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z</span><span class="p">])</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        
        <span class="c"># Compute the length-scale for the finite difference method</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span>
        
        <span class="c"># Fill the solution matrix</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
            <span class="c"># Get the end-points of z for the finite difference formula</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dz</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">:</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span>
                <span class="n">z0</span> <span class="o">=</span> <span class="n">z1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dz</span>
            <span class="k">elif</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dz</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">:</span>
                <span class="n">z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="n">z0</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z0</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dz</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dz</span>
            
            <span class="c"># Get the density at z0 and z1.  Use atmospheric pressure to </span>
            <span class="c"># compute the potential density and remove the effect of </span>
            <span class="c"># compressibility</span>
            <span class="n">T0</span><span class="p">,</span> <span class="n">S0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">S1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">Pa</span> <span class="o">=</span> <span class="mf">101325.</span>
            <span class="n">rho_0</span> <span class="o">=</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">S0</span><span class="p">,</span> <span class="n">Pa</span><span class="p">)</span>
            <span class="n">rho_1</span> <span class="o">=</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">Pa</span><span class="p">)</span>
            <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">9.81</span> <span class="o">/</span> <span class="n">rho_0</span> <span class="o">*</span> <span class="p">(</span><span class="n">rho_1</span> <span class="o">-</span> <span class="n">rho_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z0</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">N</span><span class="p">[</span><span class="n">elements</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="Profile.extend_profile_deeper"><a class="viewcode-back" href="../ambient/ambient.Profile.extend_profile_deeper.html#ambient.Profile.extend_profile_deeper">[docs]</a>    <span class="k">def</span> <span class="nf">extend_profile_deeper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_new</span><span class="p">,</span> <span class="n">nc_name</span><span class="p">,</span> <span class="n">h_N</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the CTD profile to the depth `z_new` using a fixed buoyancy</span>
<span class="sd">        frequency</span>
<span class="sd">        </span>
<span class="sd">        Extends the depth of a CTD profile to the new depth `z_new` using a </span>
<span class="sd">        fixed buoyancy frequency to adjust the salinity and keeping all other</span>
<span class="sd">        variables constant below the original depth.  This should only be </span>
<span class="sd">        used when no ambient data are available and when the bottom of the </span>
<span class="sd">        original profile is deep enough that it is acceptable to assume all </span>
<span class="sd">        variables remain constant in the extention except for salinity, which </span>
<span class="sd">        is increased to maintain the desired buoyancy frequency.</span>
<span class="sd">        </span>
<span class="sd">        The fixed buoyancy frequency used to extend the profile can be </span>
<span class="sd">        specified in one of two ways:</span>
<span class="sd">        </span>
<span class="sd">        1. Specify `h_N` and `h` and let the method `buoyancy_frequency` </span>
<span class="sd">           evaluate the buoyancy frequency.  The evaluation depth is taken at</span>
<span class="sd">           the fraction `h_N` of the original CTD depth range, with </span>
<span class="sd">           `h_N` = 1.0 yielding the lowest depth in the original CTD profile.</span>
<span class="sd">           `h` is passed to `&#39;buoyancy_frequency` unchanged and sets the </span>
<span class="sd">           length-scale of the finite difference approximation.</span>
<span class="sd">        2. Specify `N` directly as a constant.  In this case, the method</span>
<span class="sd">           `buoyancy_frequency` is not called, and any values passed to </span>
<span class="sd">           `h_N` or `h` are ignored.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z_new : float</span>
<span class="sd">            New depth for the valid_max of the CTD profile</span>
<span class="sd">        nc_name : string or path</span>
<span class="sd">            Name to use when creating the new netCDF dataset with the deeper</span>
<span class="sd">            data generated by this method call.</span>
<span class="sd">        h_N : float, default 1.0</span>
<span class="sd">            Fraction of the water depth (--) at which to compute the buoyancy</span>
<span class="sd">            frequency used to extend the profile</span>
<span class="sd">        h : float, default 0.01</span>
<span class="sd">            Passed to the `buoyancy_frequency()` method.  Fraction of the </span>
<span class="sd">            water depth (--) to use as the length-scale in a finite-</span>
<span class="sd">            difference approximation to the density gradient.</span>
<span class="sd">        N : float, default is None</span>
<span class="sd">            Optional replacement of `h_N` and `h`, forcing the extension </span>
<span class="sd">            method to use `N` as the buoyancy frequency.  </span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method does not explicitely return a value; however, it does</span>
<span class="sd">        create a new netCDF dataset with a deeper depth, closes the original </span>
<span class="sd">        netCDF dataset in the object, and rebuilds the necessary object </span>
<span class="sd">        attributes to be consistent with the new netCDF dataset.  The new </span>
<span class="sd">        netCDF dataset filename is provided by `nc_name`.</span>
<span class="sd">        </span>
<span class="sd">        One may extend a profile any number of ways; this method merely </span>
<span class="sd">        provides easy access to one rational method.  If other methods are </span>
<span class="sd">        desired, it is recommended to create a new netCDF dataset with the </span>
<span class="sd">        desired deeper profile data and then use that dataset to initialize </span>
<span class="sd">        a new `Profile` object.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        buoyancy_frequency</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Get the buoyancy frequency if not already specified</span>
        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">+</span> <span class="n">h_N</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyancy_frequency</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        
        <span class="c"># Extract the conditions at the bottom of the initial profile and </span>
        <span class="c"># calculate the required density at the base of the new profile </span>
        <span class="c"># using the potential density.</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">Pa</span> <span class="o">=</span> <span class="mf">101325.</span>
        <span class="n">rho_0</span> <span class="o">=</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Pa</span><span class="p">)</span>
        <span class="n">rho_1</span> <span class="o">=</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rho_0</span> <span class="o">/</span> <span class="mf">9.81</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_new</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho_0</span>
        
        <span class="c"># Find the salinity necessary to achieve rho_1 at the new depth</span>
        <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute the optimization function for finding S at z_new</span>
<span class="sd">            </span>
<span class="sd">            Keeping the temperature constant, compute the salinity `S` needed</span>
<span class="sd">            to achieve the desired potential density at the bottom of the </span>
<span class="sd">            new profile, rho_1</span>
<span class="sd">            </span>
<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            S : float</span>
<span class="sd">                Current guess for the new salinity at the base of the extended</span>
<span class="sd">                CTD profile</span>
<span class="sd">            </span>
<span class="sd">            T, S, Pa, and rho_1 inherited from the above calculations</span>
<span class="sd">            </span>
<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            delta_rho : float</span>
<span class="sd">                Difference between the desired density `rho_1` at the base of </span>
<span class="sd">                the new profile and the current estimate of `rho` using the </span>
<span class="sd">                current guess for the salinity `S`.  </span>
<span class="sd">            </span>
<span class="sd">            Notes</span>
<span class="sd">            -----</span>
<span class="sd">            Because compressibility effects should be ignored in estimating </span>
<span class="sd">            the buoyancy frequency, the pressure `Pa` is used to yield the </span>
<span class="sd">            potential density.</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Pa</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rho_1</span> <span class="o">-</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        
        <span class="c"># Create an array of data to append at the bottom of the original</span>
        <span class="c"># profild data</span>
        <span class="n">z_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span>
        <span class="n">S_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z_1</span> <span class="o">=</span> <span class="n">z_new</span>
        <span class="n">S_1</span> <span class="o">=</span> <span class="n">S</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_1</span> <span class="o">-</span> <span class="n">z_0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">50.</span>
        <span class="n">z_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">z_0</span><span class="p">,</span> <span class="n">z_1</span><span class="o">+</span><span class="n">dz</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>
        <span class="n">z_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_1</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_new</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_1</span> <span class="o">-</span> <span class="n">S_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_1</span> <span class="o">-</span> <span class="n">z_0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_new</span> <span class="o">-</span> <span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">S_0</span>
        <span class="n">y_new</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span>
        <span class="c"># Get the right pressure</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_new</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">y_new</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">y_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                           <span class="n">y_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">9.81</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> 
                           <span class="n">z_new</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_open</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Get the netCDF attributes not already stored in self.z and </span>
            <span class="c"># self.y</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">summary</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">source</span>
            <span class="n">sea_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">sea_name</span>
            <span class="n">p_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;lat&#39;</span><span class="p">][:]</span>
            <span class="n">p_lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;lon&#39;</span><span class="p">][:]</span>
            <span class="n">p_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
            <span class="c"># Create the new netCDF file.</span>
            <span class="n">extention_text</span> <span class="o">=</span> <span class="s">&#39;: extended from </span><span class="si">%g</span><span class="s"> to </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">,</span> <span class="n">z_1</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span> <span class="o">+</span> <span class="n">extention_text</span> <span class="o">+</span> <span class="s">&#39; on date &#39;</span> <span class="o">+</span> <span class="n">ctime</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="n">create_nc_db</span><span class="p">(</span><span class="n">nc_name</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">sea_name</span><span class="p">,</span> <span class="n">p_lat</span><span class="p">,</span> 
                                   <span class="n">p_lon</span><span class="p">,</span> <span class="n">p_time</span><span class="p">)</span>
            
            <span class="c"># Fill the netCDF file with the extended profile.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">y_new</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">z_new</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            <span class="n">var_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ztsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_names</span>
            <span class="n">var_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;m&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_names</span><span class="p">)</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;extended&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_symbols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="n">fill_nc_db</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">var_symbols</span><span class="p">,</span> <span class="n">var_units</span><span class="p">,</span> 
                                 <span class="n">comments</span><span class="p">,</span> <span class="n">z_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c"># Update the interpolator.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_interpolator</span><span class="p">()</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;The netCDF dataset is already closed; &#39;</span> <span class="o">+</span> 
                               <span class="s">&#39;aborting extension.&#39;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Profile.close_nc"><a class="viewcode-back" href="../ambient/ambient.Profile.close_nc.html#ambient.Profile.close_nc">[docs]</a>    <span class="k">def</span> <span class="nf">close_nc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close the netCDF dataset</span>
<span class="sd">        </span>
<span class="sd">        Because the raw profile data are stored in a netCDF file, a pipe is </span>
<span class="sd">        open to the file source whenever this attribute of the object is in </span>
<span class="sd">        use.  Once the interpolation function is built with the complete </span>
<span class="sd">        dataset needed for a TAMOC simulation (e.g., once calls to `append`</span>
<span class="sd">        are not longer needed), the netCDF dataset does not need to remain </span>
<span class="sd">        available.  This method closes the netCDF dataset file and tells</span>
<span class="sd">        the `Profile` object that the file is closed.  All methods that do not</span>
<span class="sd">        directly read or write data to the netCDF file will continue to work.</span>
<span class="sd">        If the object is no longer used, the Python garbage collector will</span>
<span class="sd">        eventually find it and remove it from memory.        </span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Especially during code development, scrips with open netCDF files can</span>
<span class="sd">        crash, and this method will not be called.  In that case, it is</span>
<span class="sd">        likely necessary to close Python and restart a new session so that </span>
<span class="sd">        all file pointers can be flushed.  </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Close the netCDF file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_open</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c"># Remove the object attributes from memory and delete the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc_open</span> <span class="o">=</span> <span class="bp">False</span>
    
</div></div>
<div class="viewcode-block" id="create_nc_db"><a class="viewcode-back" href="../ambient/ambient.create_nc_db.html#ambient.create_nc_db">[docs]</a><span class="k">def</span> <span class="nf">create_nc_db</span><span class="p">(</span><span class="n">nc_file</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">sea_name</span><span class="p">,</span> <span class="n">p_lat</span><span class="p">,</span> <span class="n">p_lon</span><span class="p">,</span> <span class="n">p_time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an empty netCDF4-classic dataset to store ambient data</span>
<span class="sd">    </span>
<span class="sd">    Creates an netCDF dataset file in netCDF4-classic format for use in </span>
<span class="sd">    storing ambient profile data.  This function creates the minimum data</span>
<span class="sd">    structure necessary to run the TAMOC simulation models.  This includes </span>
<span class="sd">    temperature, salinity, and pressure as a function of depth, as well as</span>
<span class="sd">    the auxiliary metadata, such as latitude, longitude, and time, etc.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nc_file : file path or string</span>
<span class="sd">        File name (supplied as a path or string) to use to create the netCDF</span>
<span class="sd">        database</span>
<span class="sd">    summary : string</span>
<span class="sd">        String containing the text for the dataset global variable `summary`.</span>
<span class="sd">        This should describe the TAMOC simulation project for which the </span>
<span class="sd">        dataset was created.</span>
<span class="sd">    source : string</span>
<span class="sd">        String containing the text for the dataset global variable `source`.</span>
<span class="sd">        Use this variable to document the original source of the data (e.g., </span>
<span class="sd">        station BM54 recorded by R/V Brooks McCall).</span>
<span class="sd">    sea_name : string</span>
<span class="sd">        String containing the NODC Sea Name.  If unsure, consult the list </span>
<span class="sd">        at http://www.nodc.noaa.gov/General/NODC-Archive/seanamelist.txt</span>
<span class="sd">    p_lat : float</span>
<span class="sd">        Latitude of the CTD profile location in decimal degrees from North</span>
<span class="sd">    p_lon : float</span>
<span class="sd">        Longitude of the CTD profile location in decimal degrees from East</span>
<span class="sd">    p_time : </span>
<span class="sd">        Time the profile was taken in seconds since 1970-01-01 00:00:00 0:00</span>
<span class="sd">        following a julian calendar.  See Examples section for how to create</span>
<span class="sd">        this variable using Python&#39;s `datetime` module and the netCDF4 modules</span>
<span class="sd">        `netCDF4.date2num` and `netCDF4.num2date`.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nc : `netCDF4.Dataset` object</span>
<span class="sd">        An object that contains the empty database ready to input profile data</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function creates an empty netCDF dataset that conforms to the </span>
<span class="sd">    standard format for an Orthogonal Multidimensional Array Representation </span>
<span class="sd">    of Profiles as defined by the National Oceanographic Data Center (NODC).  </span>
<span class="sd">    See http://www.nodc.noaa.gov/data/formats/netcdf for more details.</span>
<span class="sd">    </span>
<span class="sd">    NODC recommends using a netCDF4-classic data format, which does not </span>
<span class="sd">    support groups.  This works well for this dataset, so we implement this</span>
<span class="sd">    data format here.  The documentation for the Python `netCDF4` package</span>
<span class="sd">    here https://code.google.com/p/netcdf4-python/ uses groups throughout </span>
<span class="sd">    the tutorial.  The classic format is equivalent to having the single </span>
<span class="sd">    group `root_grp`.  </span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    netCDF4 </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from datetime import datetime, timedelta</span>
<span class="sd">    &gt;&gt;&gt; from netCDF4 import num2date, date2num</span>
<span class="sd">    &gt;&gt;&gt; nc_file = &#39;./test/output/test.nc&#39;</span>
<span class="sd">    &gt;&gt;&gt; summary = &#39;Test file&#39;</span>
<span class="sd">    &gt;&gt;&gt; source = &#39;None&#39;</span>
<span class="sd">    &gt;&gt;&gt; sea_name = &#39;No Sea Name&#39;</span>
<span class="sd">    &gt;&gt;&gt; p_lat = 28.5</span>
<span class="sd">    &gt;&gt;&gt; p_lon = 270.7</span>
<span class="sd">    &gt;&gt;&gt; p_time = date2num(datetime(2010, 5, 30), </span>
<span class="sd">            units = &#39;seconds since 1970-01-01 00:00:00 0:00&#39;, </span>
<span class="sd">            calendar = &#39;julian&#39;)</span>
<span class="sd">    &gt;&gt;&gt; nc = create_nc_db(nc_file, summary, source, sea_name, p_lat, </span>
<span class="sd">            p_lon, p_time)</span>
<span class="sd">    &gt;&gt;&gt; print nc.variables</span>
<span class="sd">    OrderedDict([(&#39;time&#39;, &lt;netCDF4.Variable object at 0x76f2978&gt;), </span>
<span class="sd">                 (&#39;lat&#39;, &lt;netCDF4.Variable object at 0x76f2a98&gt;), </span>
<span class="sd">                 (&#39;lon&#39;, &lt;netCDF4.Variable object at 0x76f2ae0&gt;), </span>
<span class="sd">                 (&#39;z&#39;, &lt;netCDF4.Variable object at 0x76f2b28&gt;), </span>
<span class="sd">                 (&#39;temperature&#39;, &lt;netCDF4.Variable object at 0x76f2b70&gt;), </span>
<span class="sd">                 (&#39;salinity&#39;, &lt;netCDF4.Variable object at 0x76f2bb8&gt;), </span>
<span class="sd">                 (&#39;pressure&#39;, &lt;netCDF4.Variable object at 0x76f2c00&gt;)])</span>
<span class="sd">    &gt;&gt;&gt; print num2date(nc.variables[&#39;time&#39;][0], </span>
<span class="sd">            units = &#39;seconds since 1970-01-01 00:00:00 0:00&#39;, </span>
<span class="sd">            calendar = &#39;julian&#39;)</span>
<span class="sd">    2010-05-30 00:00:00</span>
<span class="sd">    &gt;&gt;&gt; z_data = np.linspace(0., 1500., 30.)</span>
<span class="sd">    &gt;&gt;&gt; nc.variables[&#39;z&#39;][:] = z_data</span>
<span class="sd">    &gt;&gt;&gt; nc.variables[&#39;z&#39;].valid_max = np.max(z_data)</span>
<span class="sd">    &gt;&gt;&gt; print nc.variables[&#39;z&#39;]</span>
<span class="sd">    float64 z(u&#39;z&#39;,)</span>
<span class="sd">        long_name: depth below the water surface</span>
<span class="sd">        standard_name: depth</span>
<span class="sd">        units: m</span>
<span class="sd">        axis: Z</span>
<span class="sd">        positive: down</span>
<span class="sd">        valid_min: 0.0</span>
<span class="sd">        valid_max: 1500.0</span>
<span class="sd">    unlimited dimensions = (u&#39;z&#39;,)</span>
<span class="sd">    current size = (30,)</span>
<span class="sd">    &gt;&gt;&gt; nc.close()</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">tamoc</span> <span class="kn">import</span> <span class="n">model_share</span>
    <span class="c"># Create the netCDF dataset object</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;Profile created by TAMOC.ambient for use in the TAMOC &#39;</span> <span class="o">+</span> \
            <span class="s">&#39;modeling suite&#39;</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="n">model_share</span><span class="o">.</span><span class="n">tamoc_nc_file</span><span class="p">(</span><span class="n">nc_file</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="n">nc</span><span class="o">.</span><span class="n">sea_name</span> <span class="o">=</span> <span class="n">sea_name</span>
    
    <span class="c"># Create variables for the dimensions</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s">&#39;profile&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c"># Create the time variable</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;profile&#39;</span><span class="p">,))</span>
    <span class="n">time</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;Time profile was collected&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;time&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;seconds since 1970-01-01 00:00:00 0:00&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">calendar</span> <span class="o">=</span> <span class="s">&#39;julian&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="s">&#39;T&#39;</span>
    <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_time</span>
    
    <span class="c"># Create variables for latitude and longitude</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;lat&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;profile&#39;</span><span class="p">,))</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;Latitude of the profile location&#39;</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;latitude&#39;</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;degrees_north&#39;</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="s">&#39;Y&#39;</span>
    <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_lat</span>
    
    <span class="n">lon</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;lon&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;profile&#39;</span><span class="p">,))</span>
    <span class="n">lon</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;Longitude of the profile location&#39;</span>
    <span class="n">lon</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;longitude&#39;</span>
    <span class="n">lon</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;degrees_east&#39;</span>
    <span class="n">lon</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="s">&#39;X&#39;</span>
    <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_lon</span>
    
    <span class="c"># Create the depth variable</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,))</span>
    <span class="n">z</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;depth below the water surface&#39;</span>
    <span class="n">z</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;depth&#39;</span>
    <span class="n">z</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;m&#39;</span>
    <span class="n">z</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="s">&#39;Z&#39;</span>
    <span class="n">z</span><span class="o">.</span><span class="n">positive</span> <span class="o">=</span> <span class="s">&#39;down&#39;</span>
    <span class="n">z</span><span class="o">.</span><span class="n">valid_min</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">z</span><span class="o">.</span><span class="n">valid_max</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="c"># Create variables for temperature, salinity, and pressure</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;temperature&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;Absolute temperature&#39;</span>
    <span class="n">T</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;temperature&#39;</span>
    <span class="n">T</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;K&#39;</span>
    <span class="n">T</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s">&#39;time lat lon z&#39;</span>
    
    <span class="n">S</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;salinity&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,))</span>
    <span class="n">S</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;Practical salinity&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;salinity&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;psu&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s">&#39;time lat lon z&#39;</span>
    
    <span class="n">P</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,))</span>
    <span class="n">P</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;pressure&#39;</span>
    <span class="n">P</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s">&#39;pressure&#39;</span>
    <span class="n">P</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;Pa&#39;</span>
    <span class="n">P</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s">&#39;time lat lon z&#39;</span>
    
    <span class="k">return</span> <span class="n">nc</span>

</div>
<div class="viewcode-block" id="fill_nc_db"><a class="viewcode-back" href="../ambient/ambient.fill_nc_db.html#ambient.fill_nc_db">[docs]</a><span class="k">def</span> <span class="nf">fill_nc_db</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">var_symbols</span><span class="p">,</span> <span class="n">var_units</span><span class="p">,</span> <span class="n">comments</span><span class="p">,</span> <span class="n">z_col</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add data to a netCDF4-classic ambient profile dataset</span>
<span class="sd">    </span>
<span class="sd">    This function adds data to a netCDF4-classic dataset for a single CTD</span>
<span class="sd">    profile.  It is expected that this function could be called multiple </span>
<span class="sd">    times to completely fill in a profile database.  As data are added, this </span>
<span class="sd">    method interpolates the new data to match the current z-coordinates if </span>
<span class="sd">    they are already present in the dataset.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nc : netCDF4 dataset object</span>
<span class="sd">        This is the existing netCDF dataset object that will receive the data</span>
<span class="sd">        stored in `data`.</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Table of data to add to the netCDF database.  If it contains more</span>
<span class="sd">        than one variable, the data are assumed to be arranged in columns.</span>
<span class="sd">    var_symbols : string list</span>
<span class="sd">        List of string symbol names (e.g., T, S, P, etc.) in the same order as </span>
<span class="sd">        the columns in the data array.  For chemical properties, use the </span>
<span class="sd">        key name in the `chemical_properties` database.</span>
<span class="sd">    var_units : string list</span>
<span class="sd">        List of units associated with each variable in the `var_symbols` list.</span>
<span class="sd">    comments : string list</span>
<span class="sd">        List of comments associated with each variable in the `var_symbols`</span>
<span class="sd">        list.  As a minimum, this list should include the indications </span>
<span class="sd">        &#39;measured&#39; or &#39;derived&#39; or some similar indication of the source of</span>
<span class="sd">        the data.</span>
<span class="sd">    z_col : integer, default is 0</span>
<span class="sd">        Column number of the column containing the depth data.  The first </span>
<span class="sd">        column is numbered zero.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nc : `netCDF4.Dataset` object</span>
<span class="sd">        Returns the updated netCDF4 dataset with the data and metadata </span>
<span class="sd">        included.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : </span>
<span class="sd">        The input data array must always include a column of depths.  If the</span>
<span class="sd">        input array contains a single column and the netCDF database already</span>
<span class="sd">        has a depth array, a `ValueError` is raised since it would appear the </span>
<span class="sd">        user is trying to replace the existing depth data in the netCDF </span>
<span class="sd">        database.  If such an action is required, build a new netCDF database </span>
<span class="sd">        from scratch with the correct depth data.</span>
<span class="sd">    </span>
<span class="sd">    ValueError : </span>
<span class="sd">        This function checks whether the units supplied by the user in the </span>
<span class="sd">        list `var_units` match those expected by the database.  If not, a </span>
<span class="sd">        `ValueError` is raised with a message indicating which units are </span>
<span class="sd">        incompatible.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Symbol names in the ``TAMOC`` modeling suite are `z` (depth, positive down</span>
<span class="sd">    from the sea surface), `temperature`, `salinity`, `pressure`, and chemical</span>
<span class="sd">    names from the `chemical_properties` database (see </span>
<span class="sd">    ``./data/ChemData.csv``).  Other names will be treated exactly like the </span>
<span class="sd">    chemical names, but will likely either be unused by the ``TAMOC`` modeling</span>
<span class="sd">    suite or generate errors when a different symbol is expected.  Hence, it </span>
<span class="sd">    is the responsibility of the user to ensure that all symbol names are </span>
<span class="sd">    correct when this function is called.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    create_nc_db</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ds = Dataset(&#39;./test/output/test_ds.nc&#39;, &#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; z = ds.variables[&#39;z&#39;]</span>
<span class="sd">    &gt;&gt;&gt; zp = np.array([z.valid_min, z.valid_max])  # Depth range</span>
<span class="sd">    &gt;&gt;&gt; yp = np.array([9.15, 5.20]) / 1000         # Synthetic data</span>
<span class="sd">    &gt;&gt;&gt; data = np.vstack((zp, yp)).transpose()</span>
<span class="sd">    &gt;&gt;&gt; ds = fill_nc_db(ds, data, [&#39;z&#39;, &#39;oxygen&#39;], [&#39;m&#39;, &#39;kg/m^3&#39;], </span>
<span class="sd">                        [&#39;synthetic&#39;, &#39;synthetic&#39;], z_col=0)</span>
<span class="sd">    &gt;&gt;&gt; print ds.variables.keys()</span>
<span class="sd">    [&#39;time&#39;, &#39;lat&#39;, &#39;lon&#39;, &#39;z&#39;, &#39;temperature&#39;, &#39;salinity&#39;, &#39;pressure&#39;, &#39;S&#39;, </span>
<span class="sd">    &#39;T&#39;, &#39;oxygen&#39;]</span>
<span class="sd">    &gt;&gt;&gt; ds.variables[&#39;oxygen&#39;][:].shape            # Note interpolation</span>
<span class="sd">    (34,)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Ensure the correct data types were provided</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_symbols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">var_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_symbols</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">var_units</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_units</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comments</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span><span class="n">comments</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="c"># Count the number of dependent variables in the data array</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_symbols</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c"># Handle the independent variable z</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_symbols</span><span class="p">[</span><span class="n">z_col</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">z</span><span class="p">[:]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># Fill netCDF dataset with z values in data</span>
        
        <span class="c"># Make sure the z data are in a column</span>
        <span class="k">if</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        
        <span class="c"># Insert the data into the dataset</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">fill_nc_db_variable</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span><span class="n">z_col</span><span class="p">],</span> <span class="n">var_symbols</span><span class="p">[</span><span class="n">z_col</span><span class="p">],</span> 
                                 <span class="n">var_units</span><span class="p">[</span><span class="n">z_col</span><span class="p">],</span> <span class="n">comment</span><span class="o">=</span><span class="n">comments</span><span class="p">[</span><span class="n">z_col</span><span class="p">])</span>
        <span class="n">z</span><span class="o">.</span><span class="n">valid_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z</span><span class="p">[:])</span>
        <span class="n">z</span><span class="o">.</span><span class="n">valid_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">[:])</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Use the existing z values in the netCDF dataset</span>
        
        <span class="k">if</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>    
            <span class="c"># User is trying to replace existing data; this is not allowed</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot replace existing depth data in &#39;</span> <span class="o">+</span> \
                <span class="s">&#39;netCDF dataset: </span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> \
                <span class="s">&#39;Provide multicolumn array of new data to interpolate &#39;</span> <span class="o">+</span> \
                <span class="s">&#39;profile values </span><span class="se">\n</span><span class="s">onto the existing depths grid.&#39;</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Interpolate the input data to the existing z values</span>
            
            <span class="c"># Extend the input data array to span the full range of z values</span>
            <span class="c"># in the existing netCDF database.  Assume the data at z_min and</span>
            <span class="c"># z_max of the input data array can be copied to the valid_min</span>
            <span class="c"># and valid_max depths in the netCDF dataset if the input data</span>
            <span class="c"># array extends over a subset of the existing netCDF z range.</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">z_col</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">z</span><span class="o">.</span><span class="n">valid_min</span><span class="p">:</span>
                <span class="n">ctd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">ctd</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">ctd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">valid_min</span>
                <span class="n">ctd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctd</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">z_col</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">z</span><span class="o">.</span><span class="n">valid_max</span><span class="p">:</span>
                <span class="n">ctd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">ctd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="n">ctd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">valid_max</span>
                <span class="n">ctd</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctd</span><span class="p">)</span>
            
            <span class="c"># Create the interpolation function</span>
            <span class="n">y_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="n">z_col</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">z_col</span><span class="p">],</span> <span class="n">data</span><span class="p">[:,</span><span class="n">y_cols</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            
            <span class="c"># Replace the input data with the interpolated values that match</span>
            <span class="c"># the netCDF z array</span>
            <span class="n">interp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">interp_data</span><span class="p">[:,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:]</span>
            <span class="n">interp_data</span><span class="p">[:,</span><span class="n">y_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">[:])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
    
    <span class="c"># Handle the dependent variables</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">z_col</span><span class="p">:</span>
            <span class="c"># Skip the depth data (already handeled above)</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Processes the dependent data depending on the variable type</span>
            <span class="n">std_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">var_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">))</span>
            <span class="n">long_name</span> <span class="o">=</span> <span class="n">capwords</span><span class="p">(</span><span class="n">std_name</span><span class="p">)</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">fill_nc_db_variable</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">var_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                     <span class="n">var_units</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">comment</span><span class="o">=</span><span class="n">comments</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                     <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span> 
                                     <span class="n">std_name</span><span class="o">=</span><span class="n">std_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nc</span>

</div>
<span class="k">def</span> <span class="nf">fill_nc_db_variable</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                        <span class="n">long_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">std_name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy data to a netCDF4-classic dataset variable.</span>
<span class="sd">    </span>
<span class="sd">    DO NOT CALL THIS FUNCTION DIRECTLY.  Instead, use `fill_nc_db`.</span>
<span class="sd">    </span>
<span class="sd">    This function is intended to only be called from fill_nc_db after it </span>
<span class="sd">    determines where to insert an array of data into a netCDF4 dataset.  This</span>
<span class="sd">    function could be called directly by the user, but no checking will be </span>
<span class="sd">    performed to ensure the inserted dataset is compatible with the other </span>
<span class="sd">    data in the netCDF dataset.  Moreover, dimension mismatch, rugged arrays,</span>
<span class="sd">    or other errors could occur without the preprocessing in fill_nc_db.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nc : netCDF4 data object</span>
<span class="sd">        This is the existing netCDF dataset object that will receive the new</span>
<span class="sd">        variable values.</span>
<span class="sd">    values : ndarray, shape(z,)</span>
<span class="sd">        Array of variable values to add to the netCDF database.  Must have the</span>
<span class="sd">        same dimension as the current z values in the netCDF dataset.</span>
<span class="sd">    var_name : string</span>
<span class="sd">        Name to use in the netCDF dataset.  If it already exists, the </span>
<span class="sd">        current variable space will be used; otherwise, a new variable will</span>
<span class="sd">        be created.</span>
<span class="sd">    units : string list</span>
<span class="sd">        Units of the input values</span>
<span class="sd">    comment : string, optional</span>
<span class="sd">        String containing comments for the comment attribute of the variable.</span>
<span class="sd">        For instance, &#39;Measured&#39;, &#39;Derived quantity&#39;, etc.</span>
<span class="sd">    long_name : string, optional</span>
<span class="sd">        String for the long_name attribute of the variable; only used if the</span>
<span class="sd">        variable does not already exist.</span>
<span class="sd">    std_name : string, optional</span>
<span class="sd">        String for the standard_name attribute of the variable; only used if</span>
<span class="sd">        the variable does not already exist.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nc : netCDF4 data object</span>
<span class="sd">        Returns the updated netCDF4 database with the data and metadata </span>
<span class="sd">        included</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : </span>
<span class="sd">        If the variable already exists, then the input units are checked</span>
<span class="sd">        against the units already in the database.  If they do not match, </span>
<span class="sd">        a ValueError and appriate message is raised.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="c"># Add data to an existing variable</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">units</span>
            <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Error: </span><span class="si">%s</span><span class="s"> units must be in </span><span class="si">%s</span><span class="s"> not </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> 
                             <span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">units</span><span class="p">))</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Create a new netCDF dataset variable</span>
        <span class="n">z_dim</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">z_dim</span><span class="p">))</span>
        <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">y</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>
        <span class="n">y</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="n">std_name</span>
        <span class="n">y</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="n">y</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s">&#39;time lat lon z&#39;</span>
    
    <span class="c"># Insert comments</span>
    <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">y</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
    
    <span class="k">return</span> <span class="n">nc</span>


<div class="viewcode-block" id="get_nc_db_from_roms"><a class="viewcode-back" href="../ambient/ambient.get_nc_db_from_roms.html#ambient.get_nc_db_from_roms">[docs]</a><span class="k">def</span> <span class="nf">get_nc_db_from_roms</span><span class="p">(</span><span class="n">nc_roms</span><span class="p">,</span> <span class="n">nc_file</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="n">chem_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a netCDF4-classic dataset ready to use with ``TAMOC`` simulation </span>
<span class="sd">    models from ROMS netCDF output.</span>
<span class="sd">    </span>
<span class="sd">    Some of the model variable names used in ROMS are different from those</span>
<span class="sd">    recommended for CTD data by NODC.  Moreover, ROMS output usually includes</span>
<span class="sd">    results at many horizonal grid locations; whereas, the ``TAMOC`` models</span>
<span class="sd">    expect to have profile data for a single (lat, lon) location.  This </span>
<span class="sd">    function translates the ROMS output at a specified point to a netCDF </span>
<span class="sd">    file in the format required by ``TAMOC``.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nc_roms : netCDF4 dataset object, file path or string</span>
<span class="sd">        File name (supplied as a path or string) to the ROMS output that will</span>
<span class="sd">        be used to create a ``TAMOC`` ambient profile.</span>
<span class="sd">    nc_file : file path or string</span>
<span class="sd">        File name (supplied as a path or string) to use to create the netCDF</span>
<span class="sd">        database.</span>
<span class="sd">    t_idx : integer</span>
<span class="sd">        time-index to the desired profile information (time steps)</span>
<span class="sd">    j_idx : integer</span>
<span class="sd">        j-index to the grid location where the profile should be extracted.</span>
<span class="sd">    i_idx : integer</span>
<span class="sd">        i-index to the grid location where the profile should be extracted.</span>
<span class="sd">    chem_names : string list</span>
<span class="sd">        string list of variables to extract in addition to depth, salinity, </span>
<span class="sd">        temperature, and pressure.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nc : `netCDF4.Dataset` object</span>
<span class="sd">        An object that contains the new netCDF dataset object/</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The author of this module (S. Socolofsky) is not a ROMS expert.  Variable</span>
<span class="sd">    names assumed present in ROMS were those in the netCDF file extracted from</span>
<span class="sd">    http://barataria.tamu.edu:8080/.  </span>
<span class="sd">    </span>
<span class="sd">    TODO (S. Socolofsky 7/12/2013): Determine whether other ROMS simulations</span>
<span class="sd">    will have different variable names.  If so, provide inputs to this </span>
<span class="sd">    function containing an appropriate mapping of names.</span>
<span class="sd">    </span>
<span class="sd">    TODO (S. Socolofsky 7/15/2013): The depth values returned here are not </span>
<span class="sd">    monotonically increasing.  Make sure you are using the updated octant</span>
<span class="sd">    modules.  </span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    netCDF4, octant, octant.roms</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; nc_roms = &#39;http://barataria.tamu.edu:8080/thredds/dodsC/&#39; + \\</span>
<span class="sd">                  &#39;ROMS_Daily/08122012/ocean_his_08122012_24.nc&#39;</span>
<span class="sd">    &gt;&gt;&gt; nc_file = &#39;./test/output/test_roms.nc&#39;</span>
<span class="sd">    &gt;&gt;&gt; t_idx = 0</span>
<span class="sd">    &gt;&gt;&gt; j_idx = 400</span>
<span class="sd">    &gt;&gt;&gt; i_idx = 420</span>
<span class="sd">    &gt;&gt;&gt; chem_names = [&#39;dye_01&#39;, &#39;dye_02&#39;]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">octant.roms</span>
    
    <span class="c"># Open the ROMS netCDF dataset and get global attributes</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nc_roms</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nc_roms</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">nc_roms</span>
        <span class="n">nc_roms</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">nc_roms</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">title</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="s">&#39;ROMS Simulation Data&#39;</span>
    <span class="n">sea_name</span> <span class="o">=</span> <span class="s">&#39;ROMS&#39;</span>
    
    <span class="c"># Get the depths grid for concentration data</span>
    <span class="n">zr</span> <span class="o">=</span> <span class="n">octant</span><span class="o">.</span><span class="n">roms</span><span class="o">.</span><span class="n">nc_depths</span><span class="p">(</span><span class="n">nc_roms</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="s">&#39;rho&#39;</span><span class="p">)</span>
    <span class="n">z_unit</span> <span class="o">=</span> <span class="n">zr</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">units</span>
    
    <span class="c"># Extract the depth, temperature and salinity profiles</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">zr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">]</span>
    <span class="n">z</span><span class="p">,</span> <span class="n">z_unit</span> <span class="o">=</span> <span class="n">convert_units</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z_unit</span><span class="p">)</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;temp&#39;</span><span class="p">][</span><span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">]</span>
    <span class="n">T_unit</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;temp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">T_unit</span> <span class="o">=</span> <span class="n">convert_units</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T_unit</span><span class="p">)</span>
    
    <span class="n">S</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;salt&#39;</span><span class="p">][</span><span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">]</span>
    <span class="n">S_unit</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;salt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">long_name</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">S_unit</span> <span class="o">=</span> <span class="n">convert_units</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_unit</span><span class="p">)</span>
    
    <span class="c"># Compute the pressure by integrating the density</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">compute_pressure</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">P_unit</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Pa&#39;</span><span class="p">]</span>
    
    <span class="c"># Extract any other desired datasets</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">chem_names</span><span class="p">),</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">c_units</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chem_names</span><span class="p">)):</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">chem_names</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">]</span>
        <span class="n">c_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">chem_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">c_units</span> <span class="o">=</span> <span class="n">convert_units</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">c_units</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    
    <span class="c"># Get the time and location</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;ocean_time&#39;</span><span class="p">][</span><span class="n">t_idx</span><span class="p">]</span>
    <span class="n">date_units</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;ocean_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
    <span class="n">date_cal</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;ocean_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">calendar</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">num2date</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">date_units</span><span class="p">,</span> <span class="n">calendar</span> <span class="o">=</span> <span class="n">date_cal</span><span class="p">)</span>
    <span class="n">p_time</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="s">&#39;seconds since 1970-01-01 00:00:00 0:00&#39;</span><span class="p">,</span> 
        <span class="n">calendar</span> <span class="o">=</span> <span class="s">&#39;julian&#39;</span><span class="p">)</span>
    
    <span class="n">p_lat</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;lat_rho&#39;</span><span class="p">][</span><span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;lat_rho&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">units</span> <span class="o">!=</span> <span class="s">&#39;degree_north&#39;</span><span class="p">:</span>
        <span class="n">p_lat</span> <span class="o">=</span> <span class="mf">180.0</span> <span class="o">-</span> <span class="n">p_lat</span>
    <span class="n">p_lon</span> <span class="o">=</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;lon_rho&#39;</span><span class="p">][</span><span class="n">j_idx</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nc_roms</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s">&#39;lon_rho&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">units</span> <span class="o">!=</span> <span class="s">&#39;degree_east&#39;</span><span class="p">:</span>
        <span class="n">p_lon</span> <span class="o">=</span> <span class="mf">360.0</span> <span class="o">-</span> <span class="n">p_lon</span>
    
    <span class="c"># Initialize an empty nc database </span>
    <span class="n">nc_tamoc</span> <span class="o">=</span> <span class="n">create_nc_db</span><span class="p">(</span><span class="n">nc_file</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">sea_name</span><span class="p">,</span> <span class="n">p_lat</span><span class="p">,</span> <span class="n">p_lon</span><span class="p">,</span> 
                            <span class="n">p_time</span><span class="p">)</span>
    
    <span class="c"># Stack the data and sort so that depth increases, positive down from the</span>
    <span class="c"># free surface</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="c"># Extend the dataset to the free surface at z = 0, P = 101325 Pa</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">data</span><span class="p">))</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">101325.</span>
    
    <span class="c"># Fill the database with the ROMS data</span>
    <span class="n">var_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="s">&#39;temperature&#39;</span><span class="p">,</span> <span class="s">&#39;salinity&#39;</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">chem_names</span>
    <span class="n">var_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;psu&#39;</span><span class="p">,</span> <span class="s">&#39;Pa&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">c_units</span>
    <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;ROMS Data&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_symbols</span><span class="p">)</span>
    <span class="n">nc_tamoc</span> <span class="o">=</span> <span class="n">fill_nc_db</span><span class="p">(</span><span class="n">nc_tamoc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">var_symbols</span><span class="p">,</span> <span class="n">var_units</span><span class="p">,</span> <span class="n">comments</span><span class="p">,</span> 
                          <span class="n">z_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c"># Return the completed netCDF dataset</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nc_tamoc</span><span class="p">,</span> <span class="n">nc_roms</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="extract_profile"><a class="viewcode-back" href="../ambient/ambient.extract_profile.html#ambient.extract_profile">[docs]</a><span class="k">def</span> <span class="nf">extract_profile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">z_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_start</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">p_col</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">P_atm</span><span class="o">=</span><span class="mf">101325.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to extract a CTD profile with monotonically increasing depth</span>
<span class="sd">    </span>
<span class="sd">    This function scans a complete CTD profile data array looking for </span>
<span class="sd">    direction reversals at the top and bottom of the profile.  It then removes</span>
<span class="sd">    all reversals, yielding a single profile with monotonically increasing </span>
<span class="sd">    depth.  This is particularly useful for CTD datasets that include both the</span>
<span class="sd">    up and down cast or that have not been preprocessed to remove the surface </span>
<span class="sd">    entry and swaying at the top and bottom of the profile.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Contains the complete CTD dataset in `numpy.array` format.  All </span>
<span class="sd">        columns will be preserved; only the depth column will be used to make </span>
<span class="sd">        decisions.</span>
<span class="sd">    z_col : integer, default is 0</span>
<span class="sd">        Column number of the column containing the depth data.  The first </span>
<span class="sd">        column is numbered zero.</span>
<span class="sd">    z_start : float, default is 50</span>
<span class="sd">        Depth over which reversals are considered to be at the top of the </span>
<span class="sd">        profile.  If a depth reversal is found below this value, the profile</span>
<span class="sd">        will be assumed to end there.  The top of the profile will be either</span>
<span class="sd">        the first row of data or the lowest row of data containing a reversal</span>
<span class="sd">        for which `z` &lt; `z_start`.</span>
<span class="sd">    p_col : integer, default is None</span>
<span class="sd">        Column number of the column containing the pressure data.  If the</span>
<span class="sd">        profile is artificially extended to the free surface, the pressure</span>
<span class="sd">        must approach atmospheric pressure.</span>
<span class="sd">    P_amt : float, default is 101325</span>
<span class="sd">        Value for atmospheric pressure.  This function does not do any unit</span>
<span class="sd">        conversion, so if the pressure units passed to this function are not</span>
<span class="sd">        Pa or the pressure is different than standard atmospheric pressure, </span>
<span class="sd">        then the correct value should be specified.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the start of the profile is found to occur below `z` = 0, then a row </span>
<span class="sd">    will be added to the top of the profile with depth `z` = 0 and all other </span>
<span class="sd">    values equal to their value on the next row of the profile.  This is </span>
<span class="sd">    generally needed by interpolation methods in the ``TAMOC`` simulation </span>
<span class="sd">    suite that require data throughout the water column.</span>
<span class="sd">    </span>
<span class="sd">    This function is for use in creating a CTD data array before it is </span>
<span class="sd">    added to a netCDF dataset.  Once the depths have been added to a netCDF </span>
<span class="sd">    dataset, the methods defined in this module do not allow the depth to be</span>
<span class="sd">    further changed.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Initialize counters for the start and end of the profile</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c"># Search for the start of the profile over the range z &lt; z_start</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_start</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">z_col</span><span class="p">]:</span>
            <span class="c"># Profile is reversing</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c"># Search for the end of the profile</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">z_col</span><span class="p">]:</span>
            <span class="c"># Profile is reversing</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c"># Extend the profile to the free surface if necessary</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">ctd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ctd</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">,:]</span>
        <span class="n">ctd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">z_col</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">p_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ctd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">p_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_atm</span>
        <span class="n">ctd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ctd</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
    
    <span class="c"># Return the single CTD profile</span>
    <span class="k">return</span> <span class="n">ctd</span>

</div>
<div class="viewcode-block" id="coarsen"><a class="viewcode-back" href="../ambient/ambient.coarsen.html#ambient.coarsen">[docs]</a><span class="k">def</span> <span class="nf">coarsen</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduce the size of a raw database for interpolation</span>
<span class="sd">    </span>
<span class="sd">    Removes rows from the raw input database so that linear interpolation </span>
<span class="sd">    between rows in the new dataset recovers the original data within a </span>
<span class="sd">    relative error given by `err`.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw : ndarray, shape(:,:)</span>
<span class="sd">        An array of data with the independent variable (usually depth) </span>
<span class="sd">        in the first column and the dependent variable(s) in the remaining</span>
<span class="sd">        columns.  Note that the first column is always ignored.  </span>
<span class="sd">    err : float</span>
<span class="sd">        The acceptable level of relative error for linear interpolation </span>
<span class="sd">        between rows in the output database</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : ndarray, shape(:,:)</span>
<span class="sd">        An array of data in the same organization as the raw input array, but</span>
<span class="sd">        generally with rows removed so that the interpolation error between</span>
<span class="sd">        the output data set and the raw input data are within a relative </span>
<span class="sd">        error specified by err.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; raw = np.zeros((100,3))</span>
<span class="sd">    &gt;&gt;&gt; raw[:,0] = np.arange(100)     # Vector of dependent variables</span>
<span class="sd">    &gt;&gt;&gt; raw[:,1] = np.sqrt(raw[:,0])  # Fictitious dependent variable 1</span>
<span class="sd">    &gt;&gt;&gt; raw[:,2] = raw[:,0]**2        # Fictitious dependent variable 2</span>
<span class="sd">    &gt;&gt;&gt; data = coarsen(raw, 0.5)      # Allow up to 50% error</span>
<span class="sd">    &gt;&gt;&gt; data.shape</span>
<span class="sd">    (13, 3)</span>
<span class="sd">    &gt;&gt;&gt; data[:,0]</span>
<span class="sd">    array([  0.,   1.,   2.,   3.,   5.,   8.,  12.,  17.,  25.,  36.,  51.,</span>
<span class="sd">            73.,  99.])               # Note: data are resolved in areas</span>
<span class="sd">                                      # with the greatest curvature (small z)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Set up a blank database equal in size to the input data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c"># Record the first data point</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    
    <span class="c"># Loop through the remaining data and only record a data point if err will </span>
    <span class="c"># otherwise be exceeded for any column of dependent-variable data.</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c"># Loop through each row of data</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c"># Check each column for an exceedance of the err criteria</span>
            <span class="k">if</span> <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">ea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">raw</span><span class="p">[</span><span class="n">i_0</span><span class="p">,</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ea</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="n">ea</span> <span class="o">&gt;</span> <span class="n">err</span><span class="p">:</span>
                <span class="c"># Error exceeded for this column; record this row of data</span>
                <span class="n">rec</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
            <span class="c"># Need to record this row</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="c"># Reset the baseline row for the error calculation</span>
            <span class="n">i_0</span> <span class="o">=</span> <span class="n">i</span>
    
    <span class="c"># Record the last data point</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
    
    <span class="c"># Remove all blank rows from database</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
    
    <span class="c"># Return the reduced dataset</span>
    <span class="k">return</span> <span class="n">data</span>

</div>
<div class="viewcode-block" id="stabilize"><a class="viewcode-back" href="../ambient/ambient.stabilize.html#ambient.stabilize">[docs]</a><span class="k">def</span> <span class="nf">stabilize</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Force the density profile to be stable or neutral</span>
<span class="sd">    </span>
<span class="sd">    Remove all reversals in the density profile so that it is monotonically</span>
<span class="sd">    increasing from the surface.  This function is based on the potential</span>
<span class="sd">    density so that we obtain an absolutely stable or neutral profile.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw : ndarray</span>
<span class="sd">        An array of data organized the depth, temperature, salinity, and </span>
<span class="sd">        pressure in the first four columns of the matrix.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : ndarray, shape(:,:)</span>
<span class="sd">        A new array of data with the rows removed that would have produced an </span>
<span class="sd">        unstable profile.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Profile.build_interpolator</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function would not normally be called directly, but rather is used</span>
<span class="sd">    by the `Profile.build_interpolator` method to ensure that the dataset</span>
<span class="sd">    used in the interpolator is neutrally stable.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Start by assuming all rows with depth equal to or greater than zero </span>
    <span class="c"># should be returned.</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.</span>
    
    <span class="c"># Potential density is computed at atmospheric pressure here</span>
    <span class="n">Pa</span> <span class="o">=</span> <span class="mf">101325.</span>
    
    <span class="c"># Check the density gradient to each adjacent row and remove the unstable</span>
    <span class="c"># rows</span>
    <span class="n">rho_old</span> <span class="o">=</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">Pa</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">Pa</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="o">&lt;</span> <span class="n">rho_old</span><span class="p">:</span>
            <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rho_old</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
    
    <span class="c"># Build an interpolator that contains the stable rows</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">raw</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    
    <span class="c"># Fill the T, S, and P variables of raw with the stabilized data while </span>
    <span class="c"># keeping the variability of all the other data on the original grid</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c"># Return the acceptable rows...change this to return all rows if you </span>
    <span class="c"># do not like how much data is removed.</span>
    <span class="k">return</span> <span class="n">raw</span><span class="p">[</span><span class="n">rows</span><span class="p">,:]</span>

</div>
<div class="viewcode-block" id="compute_pressure"><a class="viewcode-back" href="../ambient/ambient.compute_pressure.html#ambient.compute_pressure">[docs]</a><span class="k">def</span> <span class="nf">compute_pressure</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">fs_loc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the pressure profile by integrating the density</span>
<span class="sd">    </span>
<span class="sd">    Compute the pressure as a function of depth by integrating the density, </span>
<span class="sd">    given by the temperature and salinity profiles and the seawater equation </span>
<span class="sd">    of state in `seawater.density`.  The depth coordinate can be either </span>
<span class="sd">    positive or negative, and the free surface can be located either in the </span>
<span class="sd">    first index to the `z`-array (`fs_loc` = 0) or the last row of the </span>
<span class="sd">    `z`-array (`fs_loc` = -1).  The data are returned in the same order as the </span>
<span class="sd">    input.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Array of depths in meters.</span>
<span class="sd">    T : ndarray</span>
<span class="sd">        Array of temperatures (K) at the corresponding depths in `z`.</span>
<span class="sd">    S : ndarray</span>
<span class="sd">        Array of salinities (psu) at the corresponding depth in `z`.</span>
<span class="sd">    fs_loc : integer (0 or -1)</span>
<span class="sd">        Index to the location of the free-surface in the `z`-array.  0 </span>
<span class="sd">        corresponds to the first element of `z`, -1 corresponds to the last </span>
<span class="sd">        element.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : ndarray</span>
<span class="sd">        Array of pressures (Pa) at the corresponding depth in `z`.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    TAMOC requires the pressure as an input since seawater is compressible </span>
<span class="sd">    over modest ocean depths.  In order to avoid having to integrate the </span>
<span class="sd">    pressure over the depth anytime the density is needed, ``TAMOC`` expects </span>
<span class="sd">    the pressures to have been computed *a priori*.  </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; z = np.arange(-1500, 0, 10)</span>
<span class="sd">    &gt;&gt;&gt; T = np.linspace(4.1, 25.0, len(z)+1)</span>
<span class="sd">    &gt;&gt;&gt; S = np.linspace(36.5, 34.5, len(z)+1)</span>
<span class="sd">    &gt;&gt;&gt; fs_loc = -1</span>
<span class="sd">    &gt;&gt;&gt; P = compute_pressure(z, T, S, fs_loc)</span>
<span class="sd">    &gt;&gt;&gt; z[-1]</span>
<span class="sd">    -10</span>
<span class="sd">    &gt;&gt;&gt; P[-1]</span>
<span class="sd">    1558721.446785233</span>
<span class="sd">    &gt;&gt;&gt; z[0]</span>
<span class="sd">    -1500</span>
<span class="sd">    &gt;&gt;&gt; P[0]</span>
<span class="sd">    150155213.18007597</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Get the sign of the z-data for the midpoint of the dataset</span>
    <span class="n">z_sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>
    
    <span class="c"># Initialize an array for storing the pressures</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="mf">101325.0</span> 
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c"># Find the free surface in the z-data</span>
    <span class="k">if</span> <span class="n">fs_loc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">depth_idxs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx_0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">depth_idxs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
        <span class="n">idx_0</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c"># Compute the pressure at the free surface</span>
    <span class="n">P</span><span class="p">[</span><span class="n">idx_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">P0</span> <span class="o">+</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P0</span><span class="p">)</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">z_sign</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">idx_0</span><span class="p">]</span>
    
    <span class="c"># Compute the pressure at the remaining depths</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">depth_idxs</span><span class="p">:</span>
        <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">z_sign</span><span class="p">]</span> <span class="o">+</span> <span class="n">seawater</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">z_sign</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">z_sign</span><span class="p">],</span> 
               <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">z_sign</span><span class="p">])</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">z_sign</span><span class="p">])</span> <span class="o">*</span> <span class="n">z_sign</span>
    
    <span class="k">return</span> <span class="n">P</span>

</div>
<div class="viewcode-block" id="convert_units"><a class="viewcode-back" href="../ambient/ambient.convert_units.html#ambient.convert_units">[docs]</a><span class="k">def</span> <span class="nf">convert_units</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the values in data to standard units</span>
<span class="sd">    </span>
<span class="sd">    This function accepts a data array with variables arranged in columns, </span>
<span class="sd">    each column given by the sequential unit in units, and converts the </span>
<span class="sd">    values in the array to standard units.  The function returns both the </span>
<span class="sd">    transformed data and the new, standardized units.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : int, float, list, or ndarray</span>
<span class="sd">        Data in which the values in each column are of uniform </span>
<span class="sd">        units.</span>
<span class="sd">    units : string list</span>
<span class="sd">        A list of strings stating the units of the input data array.  The </span>
<span class="sd">        squence of strings in the list must match the units of each column</span>
<span class="sd">        of data</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A tuple containing:</span>
<span class="sd">    </span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Array of data in the same order as the input array, but converted to</span>
<span class="sd">        standard units.</span>
<span class="sd">    units : string list</span>
<span class="sd">        A list of strings stating the new, standardized units of the values in </span>
<span class="sd">        data.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function assumes that for a one-dimensional array, each element has </span>
<span class="sd">    a unique unit.  That is, one-dimensional arrays are assumed to be rows</span>
<span class="sd">    with the number of columns equal to the number of values.  If a single </span>
<span class="sd">    column of data must be converted, you may pass</span>
<span class="sd">    `numpy.atleast_2d(data).transpose()`.  </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = np.array([[10, 25.4, 9.5, 34], [100, 10.7, 8.4, 34.5]])</span>
<span class="sd">    &gt;&gt;&gt; units = [&#39;m&#39;, &#39;deg C&#39;, &#39;mg/l&#39;, &#39;psu&#39;]</span>
<span class="sd">    &gt;&gt;&gt; data, units = convert_units(data, units)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([[  1.00000000e+01,   2.98550000e+02,   9.50000000e-03,</span>
<span class="sd">              3.40000000e+01],</span>
<span class="sd">           [  1.00000000e+02,   2.83850000e+02,   8.40000000e-03,</span>
<span class="sd">              3.45000000e+01]])</span>
<span class="sd">    &gt;&gt;&gt; units</span>
<span class="sd">    [&#39;m&#39;, &#39;K&#39;, &#39;kg/m^3&#39;, &#39;psu&#39;]</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; data = 10</span>
<span class="sd">    &gt;&gt;&gt; units = &#39;deg C&#39;</span>
<span class="sd">    &gt;&gt;&gt; data, units = convert_units(data, units)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([283])</span>
<span class="sd">    &gt;&gt;&gt; units</span>
<span class="sd">    [&#39;K&#39;]</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Build the dictionary of units conversions</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;m&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">],</span> 
               <span class="s">&#39;meter&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">],</span> 
               <span class="s">&#39;deg C&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">273.15</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">],</span> 
               <span class="s">&#39;Celsius&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">273.15</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">],</span> 
               <span class="s">&#39;K&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">],</span>
               <span class="s">&#39;db&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.e4</span><span class="p">,</span> <span class="mf">101325.</span><span class="p">,</span> <span class="s">&#39;Pa&#39;</span><span class="p">],</span> 
               <span class="s">&#39;Pa&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;Pa&#39;</span><span class="p">],</span>
               <span class="s">&#39;mg/m^3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.e-6</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;kg/m^3&#39;</span><span class="p">],</span> 
               <span class="s">&#39;S/m&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;S/m&#39;</span><span class="p">],</span> 
               <span class="s">&#39;psu&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;psu&#39;</span><span class="p">],</span> 
               <span class="s">&#39;salinity&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;psu&#39;</span><span class="p">],</span> 
               <span class="s">&#39;kg/m^3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;kg/m^3&#39;</span><span class="p">],</span> 
               <span class="s">&#39;kilogram meter-3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;kg/m^3&#39;</span><span class="p">],</span> 
               <span class="s">&#39;m/s&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;m/s&#39;</span><span class="p">],</span> 
               <span class="s">&#39;mg/l&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.e-3</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&#39;kg/m^3&#39;</span><span class="p">]}</span>
    
    <span class="c"># Make sure the data are a numpy array and the units are a list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">units</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">units</span><span class="p">]</span>
    
    <span class="c"># Make sure you can slice through the columns:  must be two-dimensional</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="c"># Allow conversion of a row of data if all of the same unit</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">units</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    
    <span class="c"># Convert the units</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">units</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">convert</span><span class="p">[</span><span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                        <span class="n">convert</span><span class="p">[</span><span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert</span><span class="p">[</span><span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Do not know how to convert </span><span class="si">%s</span><span class="s"> to mks units&#39;</span> <span class="o">%</span> <span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">print</span> <span class="s">&#39;Continuing without converting these units...&#39;</span>
    
    <span class="c"># Return the converted data in the original shape</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="load_raw"><a class="viewcode-back" href="../ambient/ambient.load_raw.html#ambient.load_raw">[docs]</a><span class="k">def</span> <span class="nf">load_raw</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read data from a text file.</span>
<span class="sd">    </span>
<span class="sd">    Read all of the data in a text file `fname` with `*` or `#` as comment</span>
<span class="sd">    characters.  Data are assumed to be sparated by spaces.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : string</span>
<span class="sd">        Name of file containing the data.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ctd : ndarray</span>
<span class="sd">        Array of data contained in `fname`.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.fromfile : Read data from a simple text file in single table format.</span>
<span class="sd">        Similar to the Matlab `load` function.  Does not support comments or </span>
<span class="sd">        skipped lines.  Works for text or binary files.</span>
<span class="sd">    </span>
<span class="sd">    numpy.loadtxt : A more sophisticated method to read data from a text file.</span>
<span class="sd">        This method can handle multiple data types (e.g., strings, floats, and</span>
<span class="sd">        integers together), can perform transformation on the data (e.g., date</span>
<span class="sd">        format to a date object), and can unpack to a tuple of variables.  One</span>
<span class="sd">        limitation is that all rows must have the same number of columns and </span>
<span class="sd">        there is no method to handle missing data.</span>
<span class="sd">    </span>
<span class="sd">    numpy.genfromtext : The most advanced numpy method to read data from a </span>
<span class="sd">        file. Includes the capabilities in `np.loadtxt`, but also allows for </span>
<span class="sd">        missing data, data flags, and multiple methods to replace missing data </span>
<span class="sd">        or flags.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Read all the data from the file</span>
    <span class="n">ctd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ctdfile</span><span class="p">:</span>
        
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">ctdfile</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;#&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                
                <span class="c"># This line contains data; parse the line</span>
                <span class="n">entries</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="c"># Convert data to float64</span>
                <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">))]</span>
                <span class="c"># Append to list</span>
                <span class="n">ctd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
    
    <span class="c"># Return the raw data as an numpy array</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ctd</span><span class="p">)</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/logo_holder.png" alt="Logo"/>
            </a></p>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Scott A. Socolofsky.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.3</a>
      
    </div>

    

    
  </body>
</html>